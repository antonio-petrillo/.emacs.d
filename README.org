#+AUTHOR: Antonio Petrillo
#+TITLE: Emacs Config

* To setup 
+ csv, json, yaml, edn ....
+ docker/podman
+ tramp
+ mail setup (notmuch)

* Early Init file
#+begin_src emacs-lisp :tangle "early-init.el"
;;; early-init.el --- Doom's universal bootstrapper -*- lexical-binding: t -*-
#+end_src

I use the directory specified in /nto-cache/ to store any part of the configuration that litter the *user-emacs-directory*.
#+begin_src emacs-lisp :tangle "early-init.el"
(defvar nto-cache (file-name-concat (getenv "HOME") ".config/nto.d"))

(unless (file-exists-p nto-cache)
  (make-directory nto-cache t))
#+end_src

Tell emacs to store all the extra information inside the /cache/ and keep the config direcotry clean.
#+begin_src emacs-lisp :tangle "early-init.el"
(startup-redirect-eln-cache (expand-file-name "eln" nto-cache))
(setq package-user-dir (expand-file-name "elpa" nto-cache))

(setq no-littering-etc-directory (expand-file-name "etc" nto-cache))
(setq no-littering-var-directory (expand-file-name "var" nto-cache))

(setq custom-file (file-name-concat nto-cache "custom.el"))
(load custom-file :no-error-if-file-is-missing)

(setq make-backup-files nil)
(setq create-lockfiles nil)

(setq package-enable-at-startup nil)
(setq evil-want-keybinding nil)
(setq use-short-answers t)
(setq ring-bell-function 'ignore)
#+end_src

On startup open emacs on a scratch buffer in fundamental mode, also enable truncate lines.
#+begin_src emacs-lisp :tangle "early-init.el"
(setq inhibit-splash-screen t)
(setq-default truncate-lines t)
(setq inhibit-startup-screen t)
#+end_src

Stolen (as many other things) from [[https://github.com/doomemacs/doomeacs][doomemacs]] early init.
As they report, disabling /scroll-bar/, /menu-bar/ and /tool-bar/ in this way avoid some redraws during startup making it faster. 
#+begin_src emacs-lisp :tangle "early-init.el"
(add-to-list 'default-frame-alist 
             '(menu-bar-lines . 0))
(add-to-list 'default-frame-alist
             '(tool-bar-lines . 0))
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))

(setq menu-bar-mode nil
      tool-bar-mode nil
      scroll-bar-mode nil)
#+end_src

I prefer to start Emacs as maximized, work well in desktop environment and it is ignored on window manager.
#+begin_src emacs-lisp :tangle "early-init.el"
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Stolen from [[https://protesilaos.com/emacs/dotemacs][Protesilaos]] (as many other things).
It set the threashold for the garbage collector to the maximum value avoding as many as possible gb collections.
After the init the threashold is set to a more sensible number.
Leaving it at ~most-positive-fixnum~ is a bad idea, emacs will chug a lot memory.
#+begin_src emacs-lisp :tangle "early-init.el"
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.5)

(defvar nto/file-name-handler-alist file-name-handler-alist)
(defvar nto/vc-handled-backends vc-handled-backends)

(setq file-name-handler-alist nil
      vc-handled-backends nil)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 16 1024 1024)
                  gc-cons-percentage 0.1
                  file-name-handler-alist nto/file-name-handler-alist
                  vc-handled-backends nto/vc-handled-backends)))
#+end_src

#+begin_src emacs-lisp :tangle "early-init.el"
;;; early-init.el ends here
#+end_src

* Init file 
#+begin_src emacs-lisp :tangle "init.el"
;;; init.el -*- lexical-binding: t; -*-
#+end_src

All my modules reside under the ~lisp/~ folder (for now)
#+begin_src emacs-lisp :tangle "init.el"
(add-to-list 'load-path (expand-file-name "lisp/" user-emacs-directory))
#+end_src

I've taken this snippet from [[https://systemcrafters.net/][System Crafters]] I think.
With this config the startup is around: ~0.48~ seconds with ~0~ garbage collections.
#+begin_src emacs-lisp :tangle "init.el"
(defun nto/display-startup-time ()
  (message
   "Emacs loaded in %s with %d garbage collections."
   (format
    "%.2f seconds"
    (float-time
     (time-subtract after-init-time before-init-time)))
   gcs-done))

(add-hook 'emacs-startup-hook #'nto/display-startup-time)
#+end_src

Each module is explained in his own section.
#+begin_src emacs-lisp :tangle "init.el"
(require 'init-elpaca-bootstrap)
(require 'init-emacs)
(require 'init-windows)
(require 'init-dired)
(require 'init-completion)
(require 'init-evil)
(require 'init-jumps)
(require 'init-org)
(require 'init-notes)
(require 'init-ui)
(require 'init-proj)
(require 'init-text-goodies)
(require 'init-snippets)
(require 'init-themes)
(require 'init-fonts)
(require 'init-applications)
(require 'init-eat)
(require 'init-strokes)
(require 'init-eshell)
(require 'init-prog)
#+end_src

Each programming languages is configured separately, with the ~nto/enable-languages~ I can enable/disable them.
To disable a language just remove it from the list.
#+begin_src emacs-lisp :tangle "init.el"
(with-eval-after-load 'init-prog
  (nto/enable-languages
   '(emacs-lisp
     clojure
     go
     odin
     zig
     ocaml)))
#+end_src

#+begin_src emacs-lisp :tangle "init.el"
;;; init.el ends here
#+end_src

* Modules
** Elpaca bootstrap
The first thing to do is to bootstrap the [[https://github.com/progfolio/elpaca][elpaca]] package manager, this configuration is taken straight up (not straight.el).
The only thing I've changed is the ~elpaca-directory~, instead of using the ~user-emacs-directory~ I use the cache directory ~nto-cache~.
#+begin_src emacs-lisp :tangle "lisp/init-elpaca-bootstrap.el" :mkdirp yes
;;; init-elpaca-bootstrap.el -*- lexical-binding: t; -*-

(defvar elpaca-installer-version 0.9)
(defvar elpaca-directory (expand-file-name "elpaca/" nto-cache))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                       :ref nil :depth 1 :inherit ignore
                       :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                       :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

(elpaca elpaca-use-package
        (elpaca-use-package-mode))

(provide 'init-elpaca-bootstrap)
;;; init-elpaca-bootstrap.el ends here
#+end_src

NOTE: Using *elpaca* I should replace the ~after-init-hook~ with ~elpaca-after-init~.

** Configure Builtin packages
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
;;; init-emacs.el -*- lexical-binding: t; -*-
#+end_src

Enhance the ~keyboard-quit~ based on the actual context.
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(defun nto/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))
#+end_src

Change the behaviour of ~backward-kill-word~ that drive me nuts.
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(defun nto/backward-kill-word()
  "Same as `backward-kill-word' but if it is invoked on a white space character
at the beginning of the line it will stop at it, furthermore if it is invoked
on the beginning of the line it will go the end of the previous line instead
of delete the previous word."
  (interactive)
  (let ((same? (save-excursion
                 (let ((orig (line-number-at-pos (point)))
                       (dest (progn
                               (backward-word)
                               (line-number-at-pos (point)))))
                   (eq orig dest))))
        (start? (eq (point) (line-beginning-position))))
    (cond (start? (backward-delete-char 1))
          (same? (backward-kill-word 1))
          (:else (kill-line 0)))))
#+end_src

Configure emacs variable, in order:
- /strokes/ for mouse gestures
- /mouse/ drag files
- add line number on while programming
- enable text folding
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(use-package emacs
  :ensure nil
  :custom
  (strokes-file (expand-file-name "strokes" nto-cache))
  (hl-line-sticky-flag nil)
  (mouse-drag-and-drop-region t)
  (mouse-drag-and-drop-region-cross-program t)
  (mouse-autoselect-window nil)
  (strokes-use-strokes-buffer nil)
  (auto-save-default nil)
  :init
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
  (add-hook 'prog-mode-hook (lambda () 
			      (display-line-numbers-mode 1)
			      (setq display-line-numbers 'relative)))
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (define-key global-map (kbd "M-c") nil)
  (define-key global-map (kbd "C-<backspace>") #'nto/backward-kill-word)
  (define-key global-map (kbd "C-g") #'nto/keyboard-quit-dwim)
  (define-key global-map (kbd "<esc>") #'nto/keyboard-quit-dwim)
  (define-key global-map (kbd "<escape>") #'nto/keyboard-quit-dwim)

  (global-set-key (kbd "M-<down-mouse-1>") 'strokes-do-stroke)

  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)

  (global-hl-line-mode)
  (auto-save-mode -1)
  (load-theme 'modus-vivendi))
#+end_src

No littering is not builtin but it is essential to not pollute the config directory.
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(use-package no-littering
  :ensure t)
#+end_src

Overwrite region when writing, no that useful with /evil-mode/ but in a few cases I still use the /emacs-state/. 
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(use-package delsel
  :ensure nil
  :hook (elpaca-after-init . delete-selection-mode))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(use-package electric
  :ensure nil
  :hook
  (prog-mode . electric-pair-mode)
  :config
  (setq electric-pair-pairs '((?\{ . ?\})
			      (?\[ . ?\])
			      (?\( . ?\))
			      (?\" . ?\"))))
#+end_src

Add the bindings for ~tab-bar~ commands, also there is a sneak peek about the ~<leader>~ key.
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(use-package tab-bar
  :bind
  (("<leader> <tab>s" . tab-switch)
   ("<leader> <tab><tab>" . tab-switch)
   ("<leader> <tab>c" . tab-close)
   ("<leader> <tab>n" . tab-new)
   ("<leader> <tab>r" . tab-rename)
   ("<leader> <tab>b" . switch-to-buffer-other-tab)
   ("<leader> <tab>d" . dired-other-tab)))
#+end_src

A brief reminder: I should research a way to customize the tab-bar aspect, it is a great place to put something like a battery indicator. 
#+begin_src emacs-lisp :tangle "lisp/init-emacs.el" :mkdirp yes
(provide 'init-emacs)
;;; lisp/init-emacs.el ends here
#+end_src

** Configure Window managements
Windows here stands for emacs windows, not the OS.

#+begin_src emacs-lisp :tangle "lisp/init-windows.el" :mkdirp yes
;;; init-window.el -*- lexical-binding: t; -*-
#+end_src

Set rules for popup buffers, here a resource on the topic made my [[https://www.youtube.com/watch?v=1-UIzYPn38s&list=PL8Bwba5vnQK3sQdwAbtdvuxUdtKSfOftA&index=6C][Prot]], also the part about occur, grep, etc... is taken from it's config with some minor changes.
#+begin_src emacs-lisp :tangle "lisp/init-windows.el" :mkdirp yes
(setq display-buffer-alist
      `(("\\*Occur\\*"
         (display-buffer-reuse-mode-window display-buffer-below-selected)
         (dedicated . t)
         (window-height . fit-window-to-buffer))

	("\\`\\*Async Shell Command\\*\\'"
	 (display-buffer-no-window))

	("\\`\\*\\(Warnings\\|Compile-Log\\|Org Links\\)\\*\\'"
	 (display-buffer-no-window)
	 (allow-no-window . t))

	((or . ((derived-mode . occur-mode)
		(derived-mode . grep-mode)
		(derived-mode . Buffer-menu-mode)
		(derived-mode . log-view-mode)
		(derived-mode . help-mode)
		"\\*\\(|Buffer List\\|Occur\\|vc-change-log\\|eldoc.*\\).*"))
	 (display-buffer-reuse-window
	  display-buffer-below-selected)
	 (dedicated . t)
	 (window-height . fit-window-to-buffer)
	 (body-function . (lambda (window) (select-window window))))))
#+end_src

Enable winner mode, this allow to have a /history/ of windows configuration.
#+begin_src emacs-lisp :tangle "lisp/init-windows.el" :mkdirp yes
(use-package winner
  :ensure nil
  :hook (elpaca-after-init . winner-mode)
  :bind
  (("<leader> wu" . winner-undo)
   ("<leader> wr" . winner-redo)))
#+end_src

Spacious padding add a pad 🤯 in the emacs frame and between windows.
Add a more aesthetic look.
#+begin_src emacs-lisp :tangle "lisp/init-windows.el" :mkdirp yes
(use-package spacious-padding
  :ensure t
  :if (display-graphic-p)
  :bind
  (("<leader> ts" . spacious-padding-mode))
  :init
  (setq spacious-padding-widths
        '( :internal-border-width 30
           :header-line-width 4
           :mode-line-width 6
           :tab-width 4
           :right-divider-width 30
           :scroll-bar-width 8
           :left-fringe-width 20
           :right-fringe-width 20))

  (setq spacious-padding-subtle-mode-line
        '( :mode-line-active spacious-padding-subtle-mode-line-active
           :mode-line-inactive spacious-padding-subtle-mode-line-inactive)))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-windows.el" :mkdirp yes
(provide 'init-windows)
;;; lisp/init-windows.el ends here
#+end_src

** Configure Dired (the best file manager) 
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
;;; init-dired.el -*- lexical-binding: t; -*-
#+end_src

Dired is a builtin package, a brief description of the configuration variables:
- ~dired-recursive-copies~, ~dired-recursive-deletes~ setted to ~t~ so emacs don't ask for on recursive function
- ~delete-by-moving-to-trash~ instead of /rm/ files, move them to /trash/ directory
- ~dired-mouse-drag-files~, ~dired-make-directory-clickable~ enable mouse action in dired
- ~dired-dwim-target~, so dired try to guess target direction for some actions (i.e. copy or moving) when there are 2 dired windows
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package dired
  :ensure nil
  :commands (dired)
  :custom 
  (dired-listing-switches "-aghl -v --group-directories-first")
  :hook
  ((dired-mode . hl-line-mode))
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-mouse-drag-files t)
  (setq dired-make-directory-clickable t)
  (setq dired-dwim-target t))
#+end_src

Enable opening directory in dired in /tree/ manner.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package dired-subtree
  :ensure t
  :after dired
  :bind
  (:map dired-mode-map
        ("<tab>" . dired-subtree-toggle)
        ("TAB" . dired-subtree-toggle)
	("SPC" . nil)
        ("<backtab>" . dired-subtree-remove)
        ("S-TAB" . dired-subtree-remove))
  :config
  (setq dired-subtree-use-backgrounds nil))
#+end_src

Toggle show dotfiles in dired, binded to ~(kbd "C-h")~ like in other file manager like /nautilus/.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package dired-hide-dotfiles;
  :ensure t
  :after (dired evil-collection)
  :hook (dired-mode . dired-hide-dotfiles-mode)
  :bind
  (:map dired-mode-map
        ("C-h" . dired-hide-dotfiles-mode)))
#+end_src

Add trashed mode to easily manage the /Trash/ directory.
#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(use-package trashed
  :ensure t
  :commands (trashed)
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-dired.el" :mkdirp yes
(provide 'init-dired)
;;; init-dired.el ends here
#+end_src

** Configure completion (minibuffer, capf, etc...)
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
;;; init-completion.el -*- lexical-binding: t; -*-
#+end_src

Enable ~which-key~, always usefult to learn new shortcuts and strengthen the ones I alread know.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package which-key
  :ensure t
  :config
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay 0.01)
  (setq which-key-idle-secondary-delay 0.01)
  :init
  (which-key-mode))
#+end_src

I prefer ~vertico~ because it's better integrated with builtin functionality, I also enable ~vertico-mouse~ so I can use the mouse in minibuffer.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package vertico
  :ensure t
  :custom
  (vertico-cycle t)
  (vertico-count 12)
  :hook (elpaca-after-init . vertico-mode))

(use-package vertico-mouse
  :ensure nil
  :after vertico
  :hook (vertico-mode . vertico-mouse-mode))
#+end_src

~Marginalia~ add annotations in the minibuffer, I can cycle between annotations strategy with ~(kbd "M-A")~.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package marginalia
  :ensure t
  :hook (elpaca-after-init . marginalia-mode)
  :bind
  (:map minibuffer-local-map
	("M-A" . marginalia-cycle)))
#+end_src

~Orderless~ allow for extremely powerful (in combo with the previous listed packages) text matching in the minibufffer.
TODO: learn how to switch on the fly between differents /matching/ styles.

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"  :mkdirp yes
(defun nto/match-components-literally ()
  "Components match literally for the rest of the session."
  (interactive)
  (setq-local orderless-matching-styles '(orderless-literal)
              orderless-style-dispatchers nil))

(use-package orderless
  :ensure t
  :config
  (setq completion-styles '(orderless basic))
  (setq completion-category-defaults nil)
  (setq completion-category-overrride nil))
#+end_src

Enable ~savehist~ and ~recentf~, so the completion are based on recent file and previous searches.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el"  :mkdirp yes
(use-package savehist
  :ensure nil
  :hook (elpaca-after-init . savehist-mode)
  :config
  (add-to-list 'savehist-additional-variables 'corfu-history))

(use-package recentf
  :ensure nil
  :hook (elpaca-after-init . recentf-mode))
#+end_src

~Corfu~ enable completion at point (capf) in emacs, like in other editors like vscode.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el"  :mkdirp yes
(use-package corfu
  :ensure t
  :hook (elpaca-after-init . global-corfu-mode)
  :custom
  (corfu-auto t)
  :bind
  (:map corfu-map
        ("<tab>" . corfu-complete)
        ("C-n" . corfu-next)
        ("C-p" . corfu-previous)
        ("C-M-SPC" . corfu-insert-separator)
        ("C-q" . corfu-quick-complete))
  :config
  (setq corfu-cycle t)
  (setq tab-always-indent 'complete)
  (setq corfu-preview-current nil)
  (setq corfu-min-width 20)
  (setq corfu-popupinfo-delay '(1.25 . 0.5))
  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'
  (corfu-history-mode 1)
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)))

#+end_src

~Cape~ enhance the completion at point capabilities of emacs, integrate well with ~corfu~.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package cape
  :ensure t
  :bind
  (("C-c p" . cape-prefix-map)
   ("M-c f" . cape-file)
   ("M-c D" . cape-dabbrev)
   ("M-c d" . cape-dict)
   ("M-c h" . cape-history)
   ("M-c k" . cape-keyword)
   ("M-c l" . cape-line))
  :init
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src

~Consult~ gives me a set of commands to replace some builtin and also provide some pretty useful extra commmands.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package consult
  :ensure t
  :after evil
  :bind
  (([remap Info-search] . consult-info)
   ("M-y" . consult-yank-pop)
   ("<leader> ht" . consult-theme)

   ("<leader> jc" . consult-line)
   ("<leader> jC" . consult-goto-line)

   ("<leader> fg" . consult-ripgrep)
   ("<leader> /" . consult-ripgrep)
   ("<leader> fh" . consult-mode-command)
   ("<leader> ff" . consult-find)
   ("<leader> fl" . consult-locate)

   ("<leader> ce" . consult-compile-error)

   ("<leader> bc" . consult-bookmark)

   ("<leader> bb" . consult-buffer)
   ("<leader> bB" . consult-buffer-other-window)
   ("<leader> b C-B" . consult-buffer-other-tab)
   ("<leader> b M-B" . consult-buffer-other-frame)

   :map minibuffer-local-map
   ("M-s" . consult-history)
   ("M-r" . consult-history)))
#+end_src

~Embark~ is a great package that provide some contextual action, like a right click menu, all controlled by the keyboard obviously.
Also add ~embark~ and ~consult~ integration.
#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(use-package embark
  :ensure t
  :bind
  (("C-." . embark-act)
   ("M-." . embark-dwim)
   ("<leader> hB" . embark-bindings))
  :init
  (setq prefix-help-command #'embark-prefix-help-command)
  :config
  (add-to-list 'display-buffer-alist
	       '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		 nil
		 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :ensure t
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
(provide 'init-completion)
;;; init-completion.el ends here
#+end_src

** Make emacs more evil
Setup /evil-mode/ and related package to enable a proper modal editing.

Use ~undo-tree~ as undo mechanism, I don't bind any special key for the undo visualization tree, the builtin are fine.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package undo-tree
  :ensure t
  :custom
  (undo-tree-history-directory-alist `(("." . ,(expand-file-name "undo-tree-hist/" nto-cache))))
  :init
  (global-undo-tree-mode))
#+end_src

Install ~evil-mode~, setup *leader* and *localleader* keys, also bind a gazillion bindings.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil
  :ensure t
  :after undo-tree
  :hook (elpaca-after-init . evil-mode)
  :custom
  (evil-undo-system 'undo-tree)
  :config
  (setq evil-want-C-i-jump nil)
  (setq evil-want-C-u-delete nil)
  (setq evil-want-C-u-scroll nil)
  (setq evil-want-C-d-scroll nil)
  (setq evil-want-Y-yank-to-eol t)
  (setq evil-disable-insert-state-bindings t)
  (setq evil-split-window-below t)
  (setq evil-split-window-right t)
  (setq evil-want-fine-undo t)
  (setq evil-kill-on-visual-paste nil)

  (evil-set-initial-state 'calc-mode 'emacs)

  (define-key evil-insert-state-map (kbd "C-n") nil)
  (define-key evil-insert-state-map (kbd "C-p") nil)
  (define-key evil-insert-state-map (kbd "C-q") nil)
  (define-key evil-normal-state-map (kbd "C-.") nil)
  (define-key evil-normal-state-map (kbd "M-.") nil)

  (evil-set-leader 'normal (kbd "SPC") nil)
  (evil-set-leader 'visual (kbd "SPC") nil)
  (evil-set-leader 'operator (kbd "SPC") nil)
  (evil-set-leader 'replace (kbd "SPC") nil)
  (evil-set-leader 'motion (kbd "SPC") nil)
  (evil-set-leader 'insert (kbd "M-SPC") nil)
  (evil-set-leader 'emacs (kbd "C-c c") nil)

  (evil-set-leader 'normal (kbd "<leader> m") t)
  (evil-set-leader 'visual (kbd "<leader> m") t)
  (evil-set-leader 'operator (kbd "<leader> m") t)
  (evil-set-leader 'replace (kbd "<leader> m") t)
  (evil-set-leader 'motion (kbd "<leader> m") t)
  (evil-set-leader 'insert (kbd "<leader> m") t)

  (evil-define-key 'normal dired-mode-map
    (kbd "h") #'dired-up-directory
    (kbd "l") #'dired-find-file)

  (evil-define-key '(normal visual operator replace motion) 'global
    (kbd "gr") #'revert-buffer)

  (evil-define-key nil 'global
    (kbd "<leader> hk") #'describe-key
    (kbd "<leader> hv") #'describe-variable
    (kbd "<leader> hf") #'describe-function
    (kbd "<leader> hc") #'describe-command
    (kbd "<leader> hm") #'describe-keymap

    (kbd "<leader> .") #'find-file
    (kbd "<leader> fs") #'save-buffer
    (kbd "<leader> fd") #'dired 
    (kbd "<leader> fr") #'recentf 

    (kbd "<leader> bk") #'kill-this-buffer
    (kbd "<leader> br") #'revert-buffer

    (kbd "<leader> bm") #'bookmark-set
    (kbd "<leader> bd") #'bookmark-delete

    (kbd "<leader> SPC") #'execute-extended-command
    (kbd "<leader> C-SPC") #'execute-extended-command-for-buffer

    (kbd "<leader> tl") #'display-line-numbers-mode

    (kbd "<leader> ws") #'evil-window-split
    (kbd "<leader> wv") #'evil-window-vsplit
    (kbd "<leader> wc") #'evil-window-delete
    (kbd "<leader> wh") #'evil-window-left
    (kbd "<leader> wM") #'toggle-frame-maximized
    (kbd "<leader> wj") #'evil-window-down
    (kbd "<leader> wk") #'evil-window-up
    (kbd "<leader> wl") #'evil-window-right
    (kbd "<leader> w1") #'delete-other-windows
    (kbd "<leader> wm") #'delete-other-windows
    (kbd "<leader> w0") #'delete-window
    (kbd "<leader> wo") #'other-window)

  (evil-define-key nil 'global
    (kbd "C-a") #'beginning-of-line
    (kbd "C-e") #'end-of-line
    (kbd "C-f") #'forward-char
    (kbd "C-b") #'backward-char
    (kbd "C-p") #'previous-line
    (kbd "C-n") #'next-line
    (kbd "C-d") #'delete-char))
#+end_src

Install ~evil-collection~ to have a good /evil/ baseline in most modes and applications.
Before enable the package I blacklist some keys so they want be used by ~evil-collection~.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-collection
  :ensure t
  :after evil
  :init
  (evil-collection-init))

(with-eval-after-load 'evil-collection
  (setq evil-collection-key-blacklist
        (append '("SPC" "C-SPC" "SPC m" "C-SPC m")
                evil-collection-key-blacklist
		'("gd" "gf" "K")
                '("gr" "gR")
                '("[" "]" "gz"))))
#+end_src

The ~evil-escape~ let me go back to normal mode with a rapid combination of keys (in my case /jk/) instead of reaching for ~(kbd "<escape>")~.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-escape
  :ensure t
  :after evil
  :hook (evil-mode . evil-escape-mode)
  :config
  (setq-default evil-escape-key-sequence "jk")
  (setq-default evil-escape-delay 0.2))
#+end_src

*** Evil textobject magic
The following are a series of /evil-mode/ extension that allow for some peculiar text action. 

**** Evil exchange
Let me exchange two region by simply selecting them and mark for /exchange/ with ~(kbd "gx")~.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-exchange
  :ensure t
  :after evil
  :commands evil-exchange
  :init
  (evil-exchange-install))
#+end_src

**** Evil Lion 
Let me align the textobjects on the left, or the right, of a specific delimiter:
  #+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-lion
  :ensure t
  :after evil
  :config
  (evil-lion-mode))
#+end_src

+ ~(kbd "gl")~, align on left
+ ~(kbd "gL")~, align on right

**** Evil Surrond
Surround textobject with custom delimiters:
  #+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-surround
  :ensure t
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src
pHere some examples take from the package docs:p
| bindins               | input              | result              | Note                               |
|-----------------------+--------------------+---------------------+------------------------------------|
| cs"'                  | "Hello World"      | 'Hello World'       | change inside textobjects          |
| cs'<q>                | 'Hello World'      | <q>Hello World</q>  |                                    |
| cst"                  | <q>Hello World</q> | "Hello World"       |                                    |
| <region>S(            | a-lisp-function    | (a-lisp-function)   | work on regions                    |
| <region>s(            | a-lisp-function    | ( a-lisp-function ) | diff between s and S               |
| ds"                   | "Hello World"      | Hello World         | delete surrounding                 |
| ysiw]  (cursor on ⬇️) | He⬇llo World       | [Hello] World       | combinate with another textobjects |
| ysiw{  (cursor on ⬇️) | He⬇llo World       | { Hello } World     | diff between (), [], {}            |

**** Evil Snipe
Evil already have a snipe bounded to ~(kbd "f")~ but this package by [[https:github.com/hlissner/evil-snipe][hlissner]] enhance the defualt behaviour with repeateable movements and also other kinds of snipes.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-snipe
  :ensure t
  :after evil
  :commands evil-snipe-local-mode evil-snipe-override-local-mode
  :hook (evil-mode . evil-snipe-override-mode)
  :hook (evil-mode . evil-snipe-mode)
  :init
  (setq evil-snipe-smart-case t
        evil-snipe-scope 'line
        evil-snipe-repeat-scope 'visible
        evil-snipe-char-fold t))
#+end_src

**** Evil Visualstar 
Enhance the navigation between same symbols with ~(kbd "#")~  and  ~(kbd "*")~.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-visualstar
  :ensure t
  :after evil
  :hook (evil-mode . global-evil-visualstar-mode)
  :config
  (setq-default evil-visualstart/persistent t))
#+end_src

**** Exato
Add textobject for /xml-like/ formats.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package exato
  :ensure t
  :after evil)
#+end_src

**** Evil Nerd Commenter
Add movement to comment/decomment region or textobjects.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-nerd-commenter
  :ensure t
  :after evil
  :init
  (evil-define-key '(visual normal) 'global "gc" #'evilnc-comment-operator))
#+end_src

**** Evil Textobj Anyblock 
Add textobjects for block/body, bind to ~(kbd "b")~.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-textobj-anyblock
  :ensure t
  :after evil
  :init
  (define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
  (define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block))
#+end_src

**** Evil Multiedit
Add multiple cursor to emacs, despite the name doesn't require /evil-mode/ to work.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-multiedit
  :ensure t
  :after evil
  :config
  (evil-define-key 'normal 'global
    (kbd "M-a")   #'evil-multiedit-match-symbol-and-next
    (kbd "M-A")   #'evil-multiedit-match-symbol-and-prev)
  (evil-define-key 'visual 'global
    "R"           #'evil-multiedit-match-all
    (kbd "M-a")   #'evil-multiedit-match-and-next
    (kbd "M-A")   #'evil-multiedit-match-and-prev)
  (evil-define-key '(visual normal) 'global
    (kbd "C-M-a") #'evil-multiedit-restore)

  (with-eval-after-load 'evil-mutliedit
    (evil-define-key 'multiedit 'global
      (kbd "M-a")   #'evil-multiedit-match-and-next
      (kbd "M-S-a") #'evil-multiedit-match-and-prev
      (kbd "RET")   #'evil-multiedit-toggle-or-restrict-region)
    (evil-define-key '(multiedit multiedit-insert) 'global
      (kbd "C-n")   #'evil-multiedit-next
      (kbd "C-p")   #'evil-multiedit-prev)))
#+end_src

**** Evil Goggles 
Add visual helpers on /evil-mode/ actions.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-goggles
  :ensure t
  :config
  (evil-goggles-mode)
  (evil-goggles-use-diff-faces))
#+end_src

**** Evil Traces
Similar to /evil-goggles/ but for /iedit/ action, the one accessed by ":command" to be clear.
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(use-package evil-traces
  :ensure t
  :config
  (evil-traces-use-diff-faces) 
  (evil-traces-mode))
#+end_src

*** Evil End Here 
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
(provide 'init-evil)
;;; init-evil.el ends here
#+end_src

** Jumps
Config about specific packages that let me move from a point to another with a single shortcut.
#+begin_src emacs-lisp :tangle "lisp/init-jumps.el" :mkdirp yes
;;; init-jumps.el -*- lexical-binding: t; -*-
#+end_src

Ace-Window let me jump from a window to another visible one with a single key, also allow to perform some actions on the layout on the fly.
#+begin_src emacs-lisp :tangle "lisp/init-jumps.el" :mkdirp yes
(use-package ace-window
  :ensure t
  :after evil
  :bind
  (("<leader> ww" . ace-window)
   ("<leader> wS" . ace-swap-window)
   ("<leader> w C-w" . ace-swap-window)
   ("<leader> wx" . ace-delete-window))
  :config
  (setq aw-background nil)
  (setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (defvar aw-dispatch-alist
    '((?x aw-delete-window "Delete Window")
      (?m aw-swap-window "Swap Windows")
      (?M aw-move-window "Move Window")
      (?c aw-copy-window "Copy Window")
      (?j aw-switch-buffer-in-window "Select Buffer")
      (?n aw-flip-window)
      (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
      (?c aw-split-window-fair "Split Fair Window")
      (?v aw-split-window-vert "Split Vert Window")
      (?b aw-split-window-horz "Split Horz Window")
      (?o delete-other-windows "Delete Other Windows")
      (?? aw-show-dispatch-help))
    "List of actions for `aw-dispatch-default'."))
#+end_src

Avy jump is similar to Ace-Window but works on characters, words and line.
#+begin_src emacs-lisp :tangle "lisp/init-jumps.el" :mkdirp yes
(use-package avy
  :ensure t
  :after evil
  :bind
  (("<leader> jj" . avy-goto-char-timer)
   ("<leader> jl" . avy-goto-line)
   ("<leader> je" . avy-goto-end-of-line)
   ("<leader> jw" . avy-goto-word-0)))
#+end_src

A minimap for emacs, don't let me perform select piece of the buffer from the minimap preview, maybe need some extra configuration.
I don't use it very much.
#+begin_src emacs-lisp :tangle "lisp/init-jumps.el" :mkdirp yes
(use-package demap
  :ensure (:host gitlab :repo "sawyerjgardner/demap.el")
  :commands (demap-toggle)
  :config
  (setq demap-minimap-window-side 'right)
  (setq demap-minimap-window-width 20)
  (setq demap-minimap-window-width 20)
  :bind
  (("<leader> tm" . demap-toggle)))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-jumps.el" :mkdirp yes
(provide 'init-jumps)
;;; init-jumps.el ends here
#+end_src

** Setup Org Mode
One of the killer feature of emacs, alongside dired and magit for me.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
;;; init-org.el -*- lexical-binding: t; -*-
#+end_src

Org is a builtin package, unfortunately it binds way to many keys for.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org
  :ensure nil
  :hook
  (org-mode . variable-pitch-mode)
  :bind
  (("C-c a" . org-agenda)
   ("<leader> oa" . org-agenda)
   :map org-mode-map
   ("C-'" . nil)
   ("C-," . nil)
   ("M-;" . nil)
   ("M-l" . nil)
   ("C-c ;" . nil)
   ("<localleader> c" . org-toggle-checkbox)
   ("<localleader> di" . org-time-stamp)
   ("<localleader> ds" . org-schedule)
   ("<localleader> dd" . org-deadline)
   ("<localleader> t" . org-todo)
   ("<localleader> f" . org-footnote-new))
  :init 
  (setq org-directory (expand-file-name "~/Documents/Org"))
  (setq org-agenda-files `(,(expand-file-name "Agenda.org" org-directory)))

  (setq org-agenda-custom-commands
        `(
          ("d" "Daily Agenda"
           ((agenda ""
                    ((org-agenda-span 'day)
                     (org-deadline-warning-days 7)
                     (org-agenda-format-date "%A %-e %B %Y")
                     (org-agenda-overriding-header "Today 📆")))
            (todo "WAIT"
                  ((org-agenda-overriding-header "Waiting tasks 🕙")))))

          ("r" "Reading List"
           ((tags "reading"
                  ((org-agenda-overriding-header "Currently reading 📖")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "^\\* Reading list .*"))))
            (tags "+book-reading"
                  ((org-agenda-overriding-header "Next to read 📚")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "^\\* Reading list .*"))))))

          ("g" "Getting Things Done"
           ((tags "inbox"
                  ((org-agenda-overriding-header "Inbox: 📬")))
            (alltodo "TODO"
                  ((org-agenda-overriding-header "Act: 📌")))
            (tags "Explore"
                  ((org-agenda-overriding-header "Explore: 🔭")))))

          ("p" "Projects"
           ((tags "proj"
                  ((org-agenda-overriding-header "Projects: 🛠️")
                   (org-agenda-skip-if 'done)))
            (tags "proj"
                  ((org-agenda-overriding-header "Completed: ⚒️✅️")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))))))

          ("u" "Uni"
           ((tags "+uni-exam"
                  ((org-agenda-overriding-header "Uni: 🎓")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "^\\* Uni .*"))))
            (tags "exam"
                  ((org-agenda-overriding-header "Exams todo: 📄")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo '("PROGRESS")))))
            (tags "exam"
                  ((org-agenda-overriding-header "Current courses: 🏢")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo '("TODO")))))
            (tags "exam"
                  ((org-agenda-overriding-header "Remaining exams: 📆")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo '("WAIT")))))
            (tags "+uni+proj"
                  ((org-agenda-overriding-header "Projects: 💻")))
            (tags "exam done"
                  ((org-agenda-overriding-header "Exams Completed: 📄✅")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))))))))

  :config
  (add-hook 'org-mode-hook
	    (lambda ()
	      (setq-local electric-pair-inhibit-predicate
			  `(lambda (c)
			     (if (char-equal c ?<) t
			       (,electric-pair-inhibit-predicate c))))))

  (setq org-todo-keywords
        '((sequence "TODO(t)" "WAIT(w!)" "PROGRES(p!)" "|" "CANCEL(c!)" "DONE(d!)")))

  (evil-set-initial-state 'org-agenda-mode 'normal)
  (evil-define-key 'normal org-agenda-mode-map
    (kbd "q") #'org-agenda-quit
    (kbd "Q") #'org-agenda-Quit
    (kbd "RET") #'org-agenda-goto)

  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)
  (setq org-agenda-window-setup 'current-window)

  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-insert-heading-respect-content t)
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-ellipsis "⮧")
  (setq org-adapt-indentation nil)
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-hide-emphasis-markers t)
  (setq org-edit-src-content-indentation 0)
  (setq org-export-with-toc t)
  (setq org-cycle-emulate-tab t)
  (setq org-export-headline-levels 8))
#+end_src

Enhance the Org UI with /org-modern/.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org-modern
  :ensure t
  :after org
  :custom
  (org-modern-table nil)
  (org-modern-star nil)
  :hook ((org-mode . org-modern-mode)
         (org-agenda-finalize . org-modern-agenda)))
#+end_src

Org appear change the visibility of emphasis marker at cursor.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org-appear
  :ensure t
  :hook
  (org-mode . org-appear-mode))
#+end_src

Org fragtog enable inline display of latex formulas.
#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(use-package org-fragtog
  :ensure t
  :after org
  :custom
  (org-startup-with-latex-preview t)
  :hook
  (org-mode . org-fragtog-mode)
  :custom
  (org-format-latex-options
   (plist-put org-format-latex-options :scale 2)
   (plist-put org-format-latex-options :foreground 'auto)
   (plist-put org-format-latex-options :background 'auto)))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
(provide 'init-org)
;;; init-org.el ends here
#+end_src

*** GTD workflow 
No specific keybinding or complicated function or file structure to implement it, just my ~Agenda.org~ file and a bunch of /tags/.

1. ~Inbox~, capture and dump idea, tag them with the ~:inbox:~ tag
2. ~Act~, decide what to do with the ~inbox~ entries, either:
   + ~Discard~, just delete 
   + ~Schedule~, either put a /deadline/, /schedule/ or just a /todo/
3. ~Store~, if I don't want to act store somewhere for future uses

** Setup Denote for note taking
I use denote in combination with /org-mode/ (and sometimes /markdown/ and /txt/) to store and link my notes.
#+begin_src emacs-lisp :tangle "lisp/init-notes.el" :mkdirp yes
;;; init-notes.el -*- lexical-binding: t; -*-

(use-package denote
  :ensure t
  :hook
  ((text-mode . denote-fontify-links-mode-maybe)
   (dired-mode . denote-dired-mode)
   (markdown-mode . denote-dired-mode))
  :config
  (setq denote-directory "~/Documents/Org/notes")
  (setq denote-known-keywords '("emacs" "programming" "algorithm"
				"datastructure" "cryptography" "logbook"
                                "film" "book" "meta"
                                "linux" "windows" "fitness"))
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  :bind
  (("<leader> nn" . denote)
   ("<leader> nf" . denote-open-or-create)
   ("<leader> nN" . denote-type)
   ("<leader> nr" . denote-rename-file)
   ("<leader> nR" . denote-rename-file-using-front-matter)
   ("<leader> ni" . denote-link)
   ("<leader> nh" . denote-org-extras-link-to-heading)
   ("<leader> nI" . denote-add-links)
   ("<leader> nb" . denote-backlinks)
   ("<leader> nB" . denote-org-extras-backlinks-for-heading)

   ("<leader> nsn" . denote-sequence)
   ("<leader> nsf" . denote-sequence-dired)
   ("<leader> nsi" . denote-sequence-link)
   ("<leader> nsc" . denote-sequence-new-child-of-current)
   ("<leader> nsr" . denote-sequence-reparent)
   ("<leader> nss" . denote-sequence-new-sibling-of-current)))

(use-package consult-denote
  :ensure t
  :bind
  (("<leader> nF" . consult-denote-find)
   ("<leader> ng" . consult-denote-grep))
  :config
  (consult-denote-mode 1))

(provide 'init-notes)
;;; init-notes.el ends here
#+end_src

** Enhance Emacs UI 
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
;;; init-ui.el -*- lexical-binding: t; -*-
#+end_src

Icons for Emacs:
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package nerd-icons
  :ensure t)

(use-package nerd-icons-completion
  :ensure t
  :after marginalia
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

(use-package nerd-icons-corfu
  :ensure t
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

(use-package nerd-icons-dired
  :ensure t
  :hook
  (dired-mode . nerd-icons-dired-mode))
#+end_src

Breadcrumb, show a trace on the top of the buffer about context information, variable, inside the function, etc...
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package breadcrumb
  :ensure t
  :bind (("<leader> tb" . breadcrumb-local-mode)))
#+end_src

Rainbow mode change the face of /colors strings/ (like #ff00ff) to the color they represent.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package rainbow-mode
  :ensure t
  :commands (rainbow-mode)
  :hook (prog-mode . rainbow-mode))
#+end_src

Rainbow delimiters use a different face for each nested parentheses, really useful on lisp languages.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Pulsar highlight the line where the cursor is when it is invoked.
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package pulsar
  :ensure t
  :config
  (setopt pulsar-pulse t
          pulsar-delay 0.055
          pulsar-iterations 10
          pulsar-face 'pulsar-green
          pulsar-highlight-face 'pulsar-magenta)
  (pulsar-global-mode 1))
#+end_src

Doom modeline give a nice and moder modeline UI. 
#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(use-package doom-modeline
  :ensure t
  :hook (elpaca-after-init . doom-modeline-mode)
  :hook (doom-modeline-mode . size-indication-mode)
  :hook (doom-modeline-mode . column-number-mode)
  :config
  (setq doom-modeline-lsp-icon nil))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
(provide 'init-ui)
;;; init-ui.el ends here
#+end_src

** Project related setup
Mainly setup *magit* and *project*.
#+begin_src emacs-lisp :tangle "lisp/init-proj.el" :mkdirp yes
;;; init-proj.el -*- lexical-binding: t; -*-

(use-package project
  :ensure nil
  :bind
  (("<leader> pp" . project-switch-project)
   ("<leader> pb" . project-switch-buffer)
   ("<leader> pc" . project-compile)
   ("<leader> ps" . project-shell)
   ("<leader> pe" . project-eshell)
   ("<leader> pf" . project-find-file)
   ("<leader> pk" . project-kill-buffers)
   ("<leader> p&" . project-async-shell-command)))

(use-package transient
  :ensure t
  :defer t
  :config
  (setq transient-show-popup 0.2))

(use-package magit
  :ensure t
  :bind
  (("<leader> gg" . magit-status)))

(use-package diff-hl
  :ensure t
  :hook (elpaca-after-init . global-diff-hl-mode)
  :config
  (setq diff-hl-global-modes '(not image-mode pdf-view-mode))
  (setq vc-git-diff-switches '("--histogram"))
  (setq diff-hl-flydiff-delay 0.5)
  (setq diff-hl-update-async t)
  (setq diff-hl-show-staged-changes nil))

(provide 'init-proj)
;;; init-proj.el ends here
#+end_src

** Text goodies
Just packages that makes my life easier working with text, they are not specific to /evil-mode/.
#+begin_src emacs-lisp :tangle "lisp/init-proj.el" :mkdirp yes
;;; init-text-goodies.el -*- lexical-binding: t; -*-
#+end_src

Rotate text let me cycle between some common word patterns, i.e. true/false, top/bottom/left/right, etc...
#+begin_src emacs-lisp :tangle "lisp/init-text-goodies.el" :mkdirp yes
(use-package rotate-text
  :ensure (:host github :repo "debug-ito/rotate-text.el")
  :after evil
  :config
  (evil-define-key 'normal 'global
    (kbd "]r") #'rotate-text
    (kbd "[r") #'rotate-text-backward))
#+end_src

Self explainatory, my english sucks.
#+begin_src emacs-lisp :tangle "lisp/init-text-goodies.el" :mkdirp yes
(use-package google-translate
  :ensure t
  :custom
  (google-translate-translation-directions-alist
        '(("it" . "en") ("en" . "it")))
  (google-translate-default-source-language "it")
  (google-translate-default-target-language "en")
  :bind
  (("<leader> lp" . google-translate-at-point)
   ("<leader> lP" . google-translate-at-point-reverse))
  :init
  (add-to-list 'display-buffer-alist
	       '("\\*Google Translate\\*"
		 (display-buffer-reuse-window
		  display-buffer-below-selected)
		 (dedicated . t)
		 (window-height . fit-window-to-buffer)
		 (body-function . (lambda (window) (select-window window))))))
#+end_src

To edit markdown files (see also the /notes/ section).
#+begin_src emacs-lisp :tangle "lisp/init-text-goodies.el" :mkdirp yes
(use-package markdown-mode
  :ensure t
  :defer t
  :config
  (setq markdown-fontify-code-blocks-natively t))
#+end_src

Move line of region of text.
#+begin_src emacs-lisp :tangle "lisp/init-text-goodies.el" :mkdirp yes
(use-package drag-stuff
  :ensure t
  :bind
  (("M-j" . drag-stuff-down)
   ("M-k" . drag-stuff-up))
  :init
  (drag-stuff-global-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle "lisp/init-text-goodies.el" :mkdirp yes
(provide 'init-text-goodies)
;;; init-text-goodies.el ends here
#+end_src

** Snippet
As snippets system I'm trying ~tempel~, so far so good, but I need to study a bit how to build my own snippets.
#+begin_src emacs-lisp :tangle "lisp/init-snippets.el" :mkdirp yes
;;; init-snippets.el -*- lexical-binding: t; -*-

(use-package tempel
  :ensure t
  :custom
  (tempel-trigger-prefix "<")
  :init
  (defun tempel-setup-capf ()
    (setq-local completion-at-point-functions
                (cons #'tempel-complete
                      completion-at-point-functions)))
  (add-hook 'conf-mode-hook 'tempel-setup-capf)
  (add-hook 'prog-mode-hook 'tempel-setup-capf)
  (add-hook 'text-mode-hook 'tempel-setup-capf)
  (add-hook 'org-mode-hook 'tempel-setup-capf))

(use-package tempel-collection
  :ensure t)

(provide 'init-snippets)
;;; init-snippets.el ends here
#+end_src

** Installing Themes 
Nothing to say, just a bunch of themes.
#+begin_src emacs-lisp :tangle "lisp/init-themes.el" :mkdirp yes
;;; init-themes.el -*- lexical-binding: t; -*-

(use-package doom-themes
  :ensure t)

(use-package ef-themes
  :ensure t)

(use-package tron-legacy-theme
  :ensure t)

(use-package spacemacs-theme
  :ensure t)

(use-package anti-zenburn-theme
  :ensure t)

(use-package gruber-darker-theme
  :ensure t)

(provide 'init-themes)
;;; init-themes.el ends here
#+end_src

** Setup fonts
Setup font, both for monospaced and proportionally spaced font, [[https://www.youtube.com/watch?v=qR8JRYr4BKE&list=PL8Bwba5vnQK3sQdwAbtdvuxUdtKSfOftA&index=8][Prot]] has a good video on the topic.
My code is almost the same from the video.
#+begin_src emacs-lisp :tangle "lisp/init-fonts.el" :mkdirp yes
;;; init-fonts.el -*- lexical-binding: t; -*-

(let ((mono-spaced-font "Aporetic Serif Mono") ;; "Monospace" backup
      (proportionately-spaced-font "Aporetic Sans")) ;; "Sans" backup

  (set-face-attribute
   'default nil
   :family mono-spaced-font
   :height 120)

  (set-face-attribute
   'fixed-pitch nil
   :family mono-spaced-font
   :height 1.0)

  (set-face-attribute
   'variable-pitch nil
   :family proportionately-spaced-font
   :height 1.0))

(use-package ligature
  :ensure t
  :hook (prog-mode . ligature-mode)
  :config
  (ligature-set-ligatures 't '("www"))
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://")))

(provide 'init-fonts)
;;; init-fonts.el ends here
#+end_src

** Setup strokes
Strokes are what other platform calls mouse/touchpad gesture.
To create a stroke I need to call ~strokes-global-set-stroke~, and after perform the gesture I need a command to bind it, this section contains all the commands specific to strokes actions.
This section is in *testing* and may be deleted in the future.
#+begin_src emacs-lisp :tangle "lisp/init-strokes.el" :mkdirp yes
;;; init-strokes.el -*- lexical-binding: t; -*-

;; set of function to bind to custom `strokes'
(defun nto/jump-to-code ()
  (interactive)
  (dired "~/Code"))

(provide 'init-strokes)
;;; init-strokes.el ends here
#+end_src

** Setup Application
This section is all about packages that gives me a functionality.
#+begin_src emacs-lisp :tangle "lisp/init-applications.el" :mkdirp yes
;;; init-applications.el -*- lexical-binding: t; -*-

#+end_src
*** XDG app menu
Just an app launcher inside emacs, although it is useful sometimes I disable it.
Maybe can will be better integrated with a tiling window manager, for now I don't need it.
#+begin_src emacs-lisp 
(use-package xdg-appmenu
  :ensure (:host codeberg :repo "akib/emacs-xdg-appmenu")
  :bind
  (("C-<f2>" . xdg-appmenu)))
#+end_src

*** Distraction free writing
Darkroom make up for a pleasing writing environment.
#+begin_src emacs-lisp :tangle "lisp/init-applications.el" :mkdirp yes
(use-package darkroom
  :ensure t
  :bind
  (("<leader> tw" . darkroom-tentative-mode)))
#+end_src

*** RSS reader
Elfeed is an rss reader for emacs, I prefer to configure it with Org mode.
#+begin_src emacs-lisp :tangle "lisp/init-applications.el" :mkdirp yes
(use-package elfeed
  :ensure t
  :custom
  (elfeed-db-directory (expand-file-name "elfeed" nto-cache))
  (elfeed-show-entry-switch 'display-buffer)
  :bind
  ("<leader> of" . elfeed))

(use-package elfeed-org
  :ensure t
  :config
  (elfeed-org)
  :custom
  (rmh-elfeed-org-files (list (expand-file-name "elfeed.org" org-directory))))

(use-package elfeed-goodies
  :ensure t
  :config
  (elfeed-goodies/setup))
#+end_src

*** Application Ends Here
#+begin_src emacs-lisp :tangle "lisp/init-applications.el" :mkdirp yes
(provide 'init-applications)
;;; init-applications.el ends here
#+end_src

** Setup shells
Eshell is builtin.
#+begin_src emacs-lisp :tangle "lisp/init-eshell.el" :mkdirp yes
;;; init-eshell.el -*- lexical-binding: t; -*-
(use-package eshell
  :ensure nil
  :config 
  (setq eshell-directory-name (expand-file-name "eshell" user-emacs-directory))
  (setq eshell-aliases-file (expand-file-name "aliases" eshell-directory-name))
  :bind
  (("<leader> oe" . eshell)
   :map eshell-mode-map
   ("C-p" . eshell-previous-input)
   ("C-n" . eshell-next-input)
   ("C-l" . eshell/clear)))

(provide 'init-eshell)
;;; init-eshell.el ends here
#+end_src

Eshell aliases.
#+begin_src txt :tangle "eshell/aliases" :mkdirp yes
alias f find-file $1
alias f find-file $1
alias ft find-file-other-tab $1
alias fF find-file-other-frame $1
alias d dired $1
alias dt dired-other-tab $1
alias df dired-other-frame $1
alias b switch-to-buffer
#+end_src

I'm trying the [[https://codeberg.org/akib/emacs-eat][EAT]] terminal.

#+begin_src emacs-lisp :tangle "lisp/init-eat.el" :mkdirp yes
;;; init-eat.el -*- lexical-binding: t; -*-
(use-package eat
  :ensure (:host codeberg :repo "akib/emacs-eat")
  :init 
  (add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode)
  :bind
  (("<leader> ot" . eat)))

(provide 'init-eat)
;;; init-eat.el ends here
#+end_src

Remember to add the following to the ~.bashrc~
#+begin_src bash
[ -n "$EAT_SHELL_INTEGRATION_DIR" ] && \
  source "$EAT_SHELL_INTEGRATION_DIR/bash"
#+end_src

** Setup for programming languages 
As said in the beginning, each language is configured separately.
The per-language configuration lives inside the ~/lisp/langs~ directory.
This module is pretty simple, setup a basic config for ~eglot~ (the LSP client builtin in emacs) and create a function to load all the languages configs from a list of candidates.
#+begin_src emacs-lisp :tangle "lisp/init-prog.el" :mkdirp yes 
;;; init-prog.el -*- lexical-binding: t; -*-

(add-to-list 'load-path (expand-file-name "lisp/langs/" user-emacs-directory))

(use-package eglot
  :ensure nil
  :functions (eglot-ensure)
  :commands (eglot)
  :config
  (setq eglot-autoshutdown t))

(defun nto/enable-languages (languages)
  (dolist (lang languages)
    (require (intern (format "%s-setup" lang)))))

(provide 'init-prog)
;;; init-prog.el ends here
#+end_src


*** Clojure  
This module has the following dependencies:
- [[https://github.com/clj-kondo/clj-kondo][clj-kondo]]
- [[https://github.com/weavejester/cljfmt][clj-fmt]]
- [[https://github.com/babashka/neil][neil]]

#+begin_src emacs-lisp :tangle "lisp/langs/clojure-setup.el" :mkdirp yes
;;; clojure-setup.el -*- lexical-binding: t; -*-

(use-package paredit
  :ensure t)

(use-package parseclj
  :ensure t)

(use-package parseedn
  :ensure t)

(use-package clojure-ts-mode
  :ensure t
  :hook
  ((clojure-mode . subword-mode)
   (clojure-mode . eldoc-mode)
   (clojure-mode . cider-mode))
  :init
  (evil-define-key nil clojure-mode-map
    (kbd "<localleader> '") #'cider-jack-in-clj
    (kbd "<localleader> \"") #'cider-jack-in-cljs
    (kbd "<localleader> m") #'cider-macroexpand-1
    (kbd "<localleader> M") #'cider-macroexpand-all
    (kbd "<localleader> d") #'cider-debug-defun-at-point
    (kbd "<localleader> eb") #'cider-eval-buffer
    (kbd "<localleader> ed") #'cider-eval-defun-at-point
    (kbd "<localleader> ee") #'cider-eval-last-sexp
    (kbd "<localleader> er") #'cider-eval-region
    (kbd "<localleader> hj") #'cider-javadoc
    (kbd "<localleader> hc") #'cider-clojuredocs
    (kbd "<localleader> hn") #'cider-find-ns
    (kbd "<localleader> ha") #'cider-apropos
    (kbd "<localleader> hd") #'cider-doc
    (kbd "<localleader> hw") #'cider-clojuredocs-web
    (kbd "<localleader> nn") #'cider-browse-ns
    (kbd "<localleader> nN") #'cider-browse-ns-all
    (kbd "<localleader> nr") #'cider-ns-refresh
    (kbd "<localleader> nR") #'cider-ns-reload
    (kbd "<localleader> pp") #'cider-pprint-eval-last-sexp
    (kbd "<localleader> pP") #'cider-pprint-eval-last-sexp-to-comment
    (kbd "<localleader> q")  #'cider-quit
    (kbd "<localleader> r")  #'cider-restart
    (kbd "<localleader> tp") #'cider-test-run-project-tests
    (kbd "<localleader> tr") #'cider-test-rerun-failed-tests
    (kbd "<localleader> tt") #'cider-test-run-test))

(use-package clj-refactor
  :ensure t
  :after clojure
  :hook (clojure-mode . clj-refactor-mode)
  :config
  (evil-define-key nil clojure-mode-map
    (kbd "<localleader> r") #'hydra-cljr-help-menu/body))

(use-package cider
  :ensure t
  :after clojure
  :config 
  (setq nrepl-hide-special-buffers t
        nrepl-log-messages nil
        cider-repl-display-help-banner nil
        cider-font-lock-dynamically '(macro core function var deprecated)
        cider-overlays-use-font-lock t
        cider-print-options '(("length" 100))
        cider-prompt-for-symbol nil
        cider-repl-history-display-duplicates nil
        cider-repl-history-display-style 'one-line
        cider-repl-history-file (concat doom-cache-dir "cider-repl-history")
        cider-repl-history-highlight-current-entry t
        cider-repl-history-quit-action 'delete-and-restore
        cider-repl-history-highlight-inserted-item t
        cider-repl-history-size 1000
        cider-repl-result-prefix ";; => "
        cider-repl-use-clojure-font-lock t
        cider-repl-use-pretty-printing t
        cider-repl-wrap-history t
        cider-stacktrace-default-filters '(tooling dup)
        cider-repl-pop-to-buffer-on-connect 'display-only))

(use-package neil
  :commands (neil-find-clojure-package)
  :config
  (setq neil-prompt-for-version-p nil
        neil-inject-dep-to-project-p t)
  (evil-define-key nil clojure-mode-map 
        (kbd "<localleader> f")  #'neil-find-clojure-package))

(provide 'clojure-setup)
;;; clojure-setup.el ends here
#+end_src

*** Emacs Lisp
For now it is empty.
#+begin_src emacs-lisp :tangle "lisp/langs/emacs-lisp-setup.el" :mkdirp yes
;;; emacs-lisp-setup.el -*- lexical-binding: t; -*-

(provide 'emacs-lisp-setup)
;;; emacs-lisp-setup.el ends here
#+end_src

*** Go setup 
Dependencies:
- [[https://github.com/golang/tools/tree/master/gopls][gopls]]

#+begin_src emacs-lisp :tangle "lisp/langs/go-setup.el" :mkdirp yes
;;; go-setup.el -*- lexical-binding: t; -*-

(use-package go-mode
  :ensure t
  :hook (go-mode . eglot-ensure)
  :bind
  (("<localleader> f" . gofmt)))

(use-package go-eldoc
  :ensure t
  :config
  (add-hook 'go-mode-hook 'go-eldoc-setup))

(provide 'go-setup)
;;; go-setup.el ends here
#+end_src

*** Odin setup
An interesting low level language.
Dependencies:
- [[https://github.com/DanielGavin/ols][ols]] language server 

Note ~odin-mode~ doesn't support hs-minor-mode so I disable with a custom hook.
#+begin_src emacs-lisp :tangle "lisp/langs/odin-setup.el" :mkdirp yes
;;; odin-setup.el -*- lexical-binding: t; -*-
(defun nto/hs-minor-mode-disable-hook ()
 (hs-minor-mode -1)) 

(use-package odin-mode
  :ensure (:host sourcehut :repo "mgmarlow/odin-mode")
  :hook (odin-mode . eglot-ensure)
  :config 
  (add-hook 'odin-mode-hook (lambda () (hs-minor-mode -1)))
  :bind
  (:map odin-mode-map
    ("<localleader> b" . #'odin-build-project)
    ("<localleader> c" . #'odin-check-project)
    ("<localleader> r" . #'odin-run-project)
    ("<localleader> t" . #'odin-test-project)))

(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs
               '(odin-mode . ("ols"))))


(provide 'odin-setup)
;;; odin-setup.el ends here
#+end_src

*** Zig setup
Another interesting low level language.
Dependencies:
- [[https://github.com/zigtools/zls][zls]], language server (NOTE: I should download and compile the version matching my zig-version)

#+begin_src emacs-lisp :tangle "lisp/langs/zig-setup.el" :mkdirp yes
;;; zig-setup.el -*- lexical-binding: t; -*-

(use-package zig-mode
  :ensure t
  :hook (zig-mode . eglot-ensure)
  :config
  (setq zig-format-on-save t)
  :bind
  (:map zig-mode-map
        ("<localleader> b" . #'zig-compile)
        ("<localleader> f" . #'zig-format-buffer)
        ("<localleader> r" . #'zig-run)
        ("<localleader> t" . #'zig-test-buffer)))

(provide 'zig-setup)
;;; zig-setup.el ends here
#+end_src

*** Ocaml setup
Not that I know this language, but in the FP family is the one that I will play with in the near future.

#+begin_src emacs-lisp :tangle "lisp/langs/ocaml-setup.el" :mkdirp yes
;;; ocaml-setup.el -*- lexical-binding: t; -*-

(use-package tuareg
  :ensure t)

(use-package dune
  :ensure t)

(use-package utop
  :ensure t)

(provide 'ocaml-setup)

;;; ocaml-setup.el ends here
#+end_src
